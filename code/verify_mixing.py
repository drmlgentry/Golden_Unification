import argparse
import math

def J_invariant(s12, s23, s13, delta_deg):
    """J = c12 c23 c13^2 s12 s23 s13 sin(delta)"""
    c12 = math.sqrt(max(0.0, 1.0 - s12*s12))
    c23 = math.sqrt(max(0.0, 1.0 - s23*s23))
    c13 = math.sqrt(max(0.0, 1.0 - s13*s13))
    delta = math.radians(delta_deg)
    return c12*c23*(c13**2)*s12*s23*s13*math.sin(delta)

def scan_delta_match_sin(target_sin, s12, s23, s13, step_deg=0.1):
    """Find delta that minimizes |sin(delta)-target_sin| over [0,360]."""
    best = None
    d = 0.0
    while d <= 360.0 + 1e-12:
        score = abs(math.sin(math.radians(d)) - target_sin)
        if best is None or score < best["score"]:
            best = {"delta_deg": d, "score": score, "J": J_invariant(s12, s23, s13, d)}
        d += step_deg
    return best

def scan_delta_match_deg(target_deg, s12, s23, s13, step_deg=0.1):
    """Find delta that minimizes |delta-target_deg| over [0,360]."""
    best = None
    d = 0.0
    while d <= 360.0 + 1e-12:
        score = abs(d - target_deg)
        if best is None or score < best["score"]:
            best = {"delta_deg": d, "score": score, "J": J_invariant(s12, s23, s13, d)}
        d += step_deg
    return best

def latex_block(ckm, pmns, meta):
    return rf"""% ============================================================
% AUTO-GENERATED: Mixing verification block (CKM + PMNS)
% Generated by: code/verify_mixing.py
% ============================================================

\section{{Mixing-angle holonomy verification (CKM and PMNS)}}
\label{{sec:mixing-verification}}

\paragraph{{CKM input.}}
We take $(s_{{12}},s_{{23}},s_{{13}})$ as external inputs and scan $\delta$ on $[0,360^\circ]$ to test the holonomy-matching criterion.

\begin{{align}}
s_{{12}} &= {ckm['s12']:.6g}, &
s_{{23}} &= {ckm['s23']:.6g}, &
s_{{13}} &= {ckm['s13']:.6g}.
\end{{align}}

\paragraph{{CKM scan result.}}
The best-fit phase is
\begin{{align}}
\delta_{{\mathrm{{CKM}}}}^{{\star}} &= {ckm['best_delta_deg']:.3f}^\circ,\\
J_{{\mathrm{{CKM}}}} &= {ckm['J']:.6e},\\
\left|\sin\delta_{{\mathrm{{CKM}}}}^{{\star}}-\sin\theta_{{\mathrm{{pred}}}}\right| &= {ckm['score_sin']:.3e}.
\end{{align}}

\paragraph{{PMNS input.}}
We repeat the same scan for leptons using
\begin{{align}}
s_{{12}} &= {pmns['s12']:.6g}, &
s_{{23}} &= {pmns['s23']:.6g}, &
s_{{13}} &= {pmns['s13']:.6g}.
\end{{align}}
We compare against the leptonic predicted holonomy angle
\begin{{align}}
\theta_{{\mathrm{{pred}}}}^{{\mathrm{{PMNS}}}} &= {pmns['theta_pred_deg']:.3f}^\circ.
\end{{align}}

\paragraph{{PMNS scan result.}}
The best-fit leptonic phase is
\begin{{align}}
\delta_{{\mathrm{{PMNS}}}}^{{\star}} &= {pmns['best_delta_deg']:.3f}^\circ,\\
J_{{\mathrm{{PMNS}}}} &= {pmns['J']:.6e},\\
\left|\sin\delta_{{\mathrm{{PMNS}}}}^{{\star}}-\sin\theta_{{\mathrm{{pred}}}}^{{\mathrm{{PMNS}}}}\right|
&= {pmns['score_sin']:.3e}.
\end{{align}}

\paragraph{{Reproducibility.}}
Scan step: {meta['step_deg']:.3f}$^\circ$. Output file: \texttt{{shared/paperV\_mixing\_results.tex}}.
"""

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--ckm_s12", type=float, default=0.2243)
    ap.add_argument("--ckm_s23", type=float, default=0.0422)
    ap.add_argument("--ckm_s13", type=float, default=0.00394)
    ap.add_argument("--theta_pred_ckm_deg", type=float, default=68.8)

    # PMNS: allow either sin^2 or sin directly; we accept sin directly for consistency with CKM.
    ap.add_argument("--pmns_s12", type=float, default=math.sqrt(0.304))
    ap.add_argument("--pmns_s23", type=float, default=math.sqrt(0.573))
    ap.add_argument("--pmns_s13", type=float, default=math.sqrt(0.02220))
    ap.add_argument("--theta_pred_pmns_deg", type=float, default=69.0)

    ap.add_argument("--step_deg", type=float, default=0.1)
    ap.add_argument("--write_tex", action="store_true")
    ap.add_argument("--out_tex", type=str, default="..\\shared\\paperV_mixing_results.tex")

    args = ap.parse_args()

    # --- CKM ---
    ckm_best_sin = scan_delta_match_sin(
        target_sin=math.sin(math.radians(args.theta_pred_ckm_deg)),
        s12=args.ckm_s12, s23=args.ckm_s23, s13=args.ckm_s13,
        step_deg=args.step_deg
    )
    ckm_best_deg = scan_delta_match_deg(
        target_deg=args.theta_pred_ckm_deg,
        s12=args.ckm_s12, s23=args.ckm_s23, s13=args.ckm_s13,
        step_deg=args.step_deg
    )

    print("CKM verification (inputs):")
    print(f"s12: {args.ckm_s12}")
    print(f"s23: {args.ckm_s23}")
    print(f"s13: {args.ckm_s13}\n")

    print("CKM scan results:")
    print(f"[match_deg]  best delta_deg: {ckm_best_deg['delta_deg']:.1f}  score: {ckm_best_deg['score']:.3e}  J_ckm: {ckm_best_deg['J']:.6e}")
    print(f"[match_sin]  best delta_deg: {ckm_best_sin['delta_deg']:.1f}  score: {ckm_best_sin['score']:.3e}  J_ckm: {ckm_best_sin['J']:.6e}\n")

    # --- PMNS ---
    pmns_best_sin = scan_delta_match_sin(
        target_sin=math.sin(math.radians(args.theta_pred_pmns_deg)),
        s12=args.pmns_s12, s23=args.pmns_s23, s13=args.pmns_s13,
        step_deg=args.step_deg
    )

    print("PMNS extension (inputs):")
    print(f"s12: {args.pmns_s12:.6f}")
    print(f"s23: {args.pmns_s23:.6f}")
    print(f"s13: {args.pmns_s13:.6f}")
    print(f"theta_pred_pmns_deg: {args.theta_pred_pmns_deg:.3f}\n")

    print("PMNS scan result (match_sin to predicted theta):")
    print(f"best delta_pmns_deg: {pmns_best_sin['delta_deg']:.1f}")
    print(f"match_score |sin(delta)-sin(theta_pred)|: {pmns_best_sin['score']:.3e}")
    print(f"J_pmns: {pmns_best_sin['J']:.6e}\n")

    if args.write_tex:
        ckm_pack = {
            "s12": args.ckm_s12, "s23": args.ckm_s23, "s13": args.ckm_s13,
            "best_delta_deg": ckm_best_sin["delta_deg"],
            "score_sin": ckm_best_sin["score"],
            "J": ckm_best_sin["J"],
        }
        pmns_pack = {
            "s12": args.pmns_s12, "s23": args.pmns_s23, "s13": args.pmns_s13,
            "theta_pred_deg": args.theta_pred_pmns_deg,
            "best_delta_deg": pmns_best_sin["delta_deg"],
            "score_sin": pmns_best_sin["score"],
            "J": pmns_best_sin["J"],
        }
        meta = {"step_deg": args.step_deg}

        tex = latex_block(ckm_pack, pmns_pack, meta)

        # write UTF-8
        with open(args.out_tex, "w", encoding="utf-8") as f:
            f.write(tex)

        print(f"Wrote LaTeX block to: {args.out_tex}")

if __name__ == "__main__":
    main()
